// this code purterbe the existing model, and calculate the corresponding dispersion curve,misfit
// input an accurate Ani model, and purterbing the Vsh and fit the Love only.
// this version can set Iso_parameter. i.e., the parameter that can be perturbed and it has the same value in both R and L.  provide a file list and read into Viso[]
//
#include<iostream>
#include<algorithm>
#include<vector>
#include<cmath>
#include<fstream>
#include<omp.h>
#include"./string_split.C"
#include"./generate_Bs.C"
#include"./gen_random.C"
#include"./INITstructure.h"
#include"./CALgroup_smooth.C"
#include"./CALgroup_rf.C"
//#include"./CALmodel.C"
#include"./CALmodel_LVZ_rf.C"
#include"./CALpara_isolay_v2.C"
#include "./CALrf.C"
//#include "./CALMineos_smooth_rf_dpv2.C"
#include "CALMineos_readK_smooth_rf_dpv2_parallel.C"
#include "./ASC_rw_rf.C"
#include "./BIN_rw.C"
#include "./CALinv_isolay_rf_parallel.C"
#define NNAME 100 //length of string
#define NPOINTMAX 2000 //max # of points
using namespace std;

int main(int argc, char *argv[])
{
if(argc!=14){
printf("Usage: xx 1]input_point_file 2]output_dir_name 3]input_vsv_dir_name 4]Rphindir 5]Rgpindir 6]Lphindir 7]Lgindir 8]kernel_dir 9,10]paraR,L.in 11]dir_to_isofile 12]RF_dir 13]flagreadKernel\n");
printf("1] node_id node_lon node_lat\n3]dir/initmod/vsv_node_lon_lat.mod\n");
printf("11] isofile is generated by using generate_isolst.py\n diriso/Isolst_lon_lat.in\n");
exit(0);
}
//----shared variables------------
int isoflag,Rsurflag,Lsurflag,flagreadKernel,iitercri1,iitercri2,ijumpcri1,ijumpcri2,Rmonoc,Lmonoc,PosAnic,k1,k2,Nprem,npoint;
//double
float inp, depcri1,depcri2,qscri,qpcri,lonlst[NPOINTMAX],latlst[NPOINTMAX];
char PREMnm[NNAME],inponm[NNAME],Rphindir[NNAME],Rgpindir[NNAME],Lphindir[NNAME],Lgpindir[NNAME],dirker[NNAME],Rparanm[NNAME],Lparanm[NNAME],isodir[NNAME],tmpstrShare[200],nodeidlst[NPOINTMAX][8],dirlay[NNAME],initmoddir[NNAME],rfdir[NNAME];
vector<int> Rvmono,Lvmono,Rvgrad,Lvgrad,Vposani;
vector<vector<double> >  PREM;
FILE *fmisfit,*inpo,*fshare;
time_t dtall2=time(0);
clock_t dtall=clock();

//


  //----------------PARAMETERS-----------------------------------------
  printf("test-- set parameters\n");
  isoflag=0; //isoflag==1: Vsv=Vsh, isoflag==0: Vsv!=Vsh
  Rsurflag=1; //surflag==1: open phase only. surfalg ==3 open phase and group, surflag==2: open group only
  Lsurflag=1;
  flagreadKernel=atoi(argv[13]);
  inp = 0.5; // the weight for surface wavemisfit [0,1]
  iitercri1=3000;//10000;
  iitercri2=5000;//15000;
  ijumpcri1=4;
  ijumpcri2=8;
  depcri1=0.0;
  depcri2=0.0;
  qpcri=900.;
  qscri=250.;
  Rmonoc=1;
  Lmonoc=1;
  PosAnic=0;
  //Rvmono.push_back(0);
  //Lvmono.push_back(0);
  Rvmono.push_back(1);
  Lvmono.push_back(1);
  //Rvgrad.push_back(0);
  Rvgrad.push_back(1);//Rvgrad.push_back(2);
  //Lvgrad.push_back(0);
  Lvgrad.push_back(1);
  //Vposani.push_back(0);
  //Vposani.push_back(1);
  //Vposani.push_back(2);
  k1=0;k2=1;
  //----------------------------------------------------------------------
  printf("test-- readin PREM\n");

  //sprintf(PREMnm,"/home/jiayi/progs/jy/Mineos/Mineos-Linux64-1_0_2/DEMO/models/prem_noocean.txt");
  sprintf(PREMnm,"/home/jixi7887/progs/jy/Mineos/Mineos-Linux64-1_0_2/DEMO/models/ak135_iso_nowater.txt");
  sprintf(inponm,argv[1]);
  sprintf(dirlay,argv[2]);
  sprintf(initmoddir,argv[3]);
  sprintf(Rphindir,argv[4]);
  sprintf(Rgpindir,argv[5]);
  sprintf(Lphindir,argv[6]);
  sprintf(Lgpindir,argv[7]);
  sprintf(dirker,argv[8]);
  sprintf(Rparanm,argv[9]);
  sprintf(Lparanm,argv[10]);
  sprintf(isodir,argv[11]);
  sprintf(rfdir,argv[12]);
  readPREM(PREMnm,PREM,Nprem);

  sprintf(tmpstrShare,"if [ ! -d %s ]; then mkdir %s; fi",dirlay,dirlay);
  system(tmpstrShare);
  sprintf(tmpstrShare,"%s/misfit_bestMod_Ani.txt",dirlay);
  //fmisfit=fopen(tmpstr,"w");
  //fmisfit=fopen(tmpstrShare,"a");
  if((fshare=fopen("running_output.txt","w"))==NULL){
	printf("Hey, cannot open a share file to write!\n");
	exit(0);
  }
  sprintf(tmpstrShare,"if [ ! -d %s/initmod ]; then mkdir %s/initmod; fi",dirlay,dirlay);
  system(tmpstrShare);
  sprintf(tmpstrShare,"if [ ! -d %s/binmod ]; then mkdir %s/binmod; fi",dirlay,dirlay);
  system(tmpstrShare);


  //---------------------------------------------------------
  printf("test-- readin points\n");
  if((inpo=fopen(inponm,"r"))==NULL){
	printf("Cannot open points file %s!\n",inponm);exit(0);
  }
  
  for(npoint=0;;npoint++){
	if(npoint>NPOINTMAX){
		printf("the NPOINTMAX(%d) is not big enough! change it!\n",NPOINTMAX);
		exit(0);
	}
	if(fscanf(inpo,"%s %f %f",&nodeidlst[npoint][0],&lonlst[npoint],&latlst[npoint])!=3)
		break;
  }
  fclose(inpo);
  printf("read in %d points in total\n",npoint);

  #pragma omp parallel for
  for(int ipoint=0;ipoint<npoint;ipoint++){
    //-----define private variables----------------
    int i,j,k;
    double bestmisfit;
    float lon,lat,f;
    char nodeid[8],str[200],tmpstr[200],isonm[NNAME],outinitnm[NNAME],fbinnm1[NNAME],fbinnm2[NNAME],modnm[NNAME],rfnm[NNAME],kernelnmR[NNAME],kernelnmL[NNAME],modnm1[NNAME],modnm2[NNAME],Rdispnm1[NNAME],Rdispnm2[NNAME],Ldispnm1[NNAME],Ldispnm2[NNAME],rfoutnm1[NNAME],rfoutnm2[NNAME];
    time_t start;
    FILE *ftmp,*fkernel;
    vector<int> idlst;
    vector<float> Viso;
    vector<double> Rparastd,Lparastd;
    vector<string> Rdispnm,Ldispnm;
    vector<vector<vector<double> > > kernel1,kernel2;
    vector<paradef> paralst;
    modeldef model0,refmodel,modelbest1,modelavg;
    paradef para0,para1,refpara,parabest1,paraavg;
    //print start for each point
    //---------------------------------------------
    
    printf("test-- set value %d\n",ipoint);
    sprintf(nodeid,"%s",nodeidlst[ipoint]);
    lon=lonlst[ipoint];
    lat=latlst[ipoint];
    #pragma omp critical (writeShareFile)
    {
    printf("Begin to work on point %d: id=%s lon=%f lat=%f\n",ipoint,nodeid,lon,lat);
    fprintf(fshare,"%d  %s %f %f\n",ipoint,nodeid,lon,lat);
    }
    start=time(0);
    bestmisfit=1e10;
    
    Viso.clear();
    //sprintf(isonm,"%s",isodir);
    sprintf(isonm,"%s/Isolst_%.1f_%.1f.in",isodir,lon,lat);
    if((ftmp=fopen(isonm,"r"))==NULL){
	printf("Hey, cannot open file %s to read!\n",isonm);
	#pragma omp critical (writeShareFileError1)
	{
	fprintf(fshare," %s ERROR, cannot open isolst\n",nodeid);
	}
	continue;
    }
    while(1){
    if((fscanf(ftmp,"%f",&f))!=1)break;
    Viso.push_back(f);
     }
    fclose(ftmp); 

    Rdispnm.clear();
    sprintf(str,"%s/dispR_%s_%.1f_%.1f.in",Rphindir,nodeid,lon,lat);
    //sprintf(str,"%s",Rphindir);
    Rdispnm.push_back(str);

    Ldispnm.clear();
    sprintf(str,"%s/dispL_%s_%.1f_%.1f.in",Lphindir,nodeid,lon,lat);
    //sprintf(str,"%s",Lphindir);
    Ldispnm.push_back(str);

    //----- receiver function data----
    sprintf(rfnm,"%s/%s.RF",rfdir,nodeid);

    //-----the final output model, that will serve as input model for the next step 
    sprintf(outinitnm,"%s/initmod/ani_%s_%.1f_%.1f.mod",dirlay,nodeid,lon,lat);
    //-----the outpur binary files, all the accepted models during inversion
    sprintf(fbinnm1,"%s/binmod/ani_%s_%.1f_%.1f.bin",dirlay,nodeid,lon,lat);
    sprintf(fbinnm2,fbinnm1);//overwrite the first binary output

    //-----starting model-----the output model of last step (invert vsv)
    //sprintf(modnm,"%s/%s.mod2.1laysed",argv[3],nodeid); //fromIso
    sprintf(modnm,"%s/%s.mod1",initmoddir,nodeid);

  //---------------------------------------------------------
    printf("test-- init value  %d\n",ipoint);
    initmodel(model0);
    initmodel(refmodel);

    initpara(para0);
    initpara(para1);
    initpara(refpara);
    readdisp(model0,Rdispnm,Ldispnm,Rsurflag,Lsurflag); 
    //readmodAniso(model0,modnm);// both m.g.LV/Rv are filled regardless of flags. (readin iso model)
    readmodIso(model0,modnm);// both m.g.LV/Rv are filled regardless of flags. (readin iso model)
    readpara(para0,Rparanm,Lparanm,Rsurflag,Lsurflag);// read in para only if flag>0
    readrf(model0,rfnm);

    if (para0.Rnpara!=Viso.size()){
       printf("##### Number of parameter is different from Viso.size(), %d != %d\n",para0.Rnpara,Viso.size());
       exit(0);
    }
    mod2para(model0,para0,para1,Rsurflag,Lsurflag);////fill both para.R/Lpara0 (they could be inequal if Rf*Lf>0, they are equal if Rf*Lf=0)
    updatemodelTibet(model0,depcri1,depcri2,qpcri,qscri);
    //----------------output kernel1----------------------------------------------
    printf("test-- decide kernel %d\n",ipoint);
    if(flagreadKernel>0){  //compute disp from MINOES and read in the kernel from file
      sprintf(kernelnmR,"%s/kernelRp1ani_%s_%.1f_%.1f.txt",dirker,nodeid,lon,lat);
      sprintf(kernelnmL,"%s/kernelLp1ani_%s_%.1f_%.1f.txt",dirker,nodeid,lon,lat);
      printf("test-- read kernel\n");
      if((read_kernel(para1,model0,kernel1,kernelnmR,kernelnmL,Rsurflag,Lsurflag,PREM,Nprem,isoflag,nodeid))==0){
	 printf ("#### read_kernel failed\n");
	 #pragma omp critical (writeShareFileError2)
	 {
	 fprintf(fshare," %s ERROR, cannot open kernel file\n",nodeid);
	 }
	 continue;
      }   	
    }
    else{
      printf("test--compute kernel %s\n",nodeid);
      compute_kernel(para1,model0,kernel1,PREM,Nprem,Rsurflag,Lsurflag,isoflag,depcri1,depcri2,qpcri,qscri,nodeid);
      if(Rsurflag>0){
       printf("test-- compute Rkernel %d\n",ipoint);
       sprintf(tmpstr,"%s/kernelRp1ani_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat); 
       fkernel=fopen(tmpstr,"w");
       sprintf(tmpstr," ");
       for(i=0;i<model0.data.Rdisp.npper;i++){
        for(j=0;j<para1.Rnpara+para1.Lnpara;j++){sprintf(tmpstr,"%s %f",tmpstr,kernel1[0][j][i]);}
        fprintf(fkernel,"%f %s\n",model0.data.Rdisp.pper[i],tmpstr);
        sprintf(tmpstr," ");
        }
       fclose(fkernel);
    }
    if(Lsurflag>0){
       printf("test-- compute Lkernel %d\n",ipoint);
       sprintf(tmpstr,"%s/kernelLp1ani_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat); 
       fkernel=fopen(tmpstr,"w");
       sprintf(tmpstr," ");
       for(i=0;i<model0.data.Ldisp.npper;i++){
        for(j=0;j<para1.Lnpara+para1.Rnpara;j++){sprintf(tmpstr,"%s %f",tmpstr,kernel1[2][j][i]);}
        fprintf(fkernel,"%f %s\n",model0.data.Ldisp.pper[i],tmpstr);
        sprintf(tmpstr," ");
        }
       fclose(fkernel);
    }
   }//else
   
   printf("test-- cpt rf\n");
   compute_rf(model0,depcri1,depcri2,qpcri,qscri);   //compute RF from theo
  //------------COMPUTE KERNEL1 BASED ON INPUT MODEL AND DO THE FIRST INVERSION---------------------------
    //compute_misfitDISP(model0,Rsurflag,Lsurflag);
    printf("test-- cpt misfit\n");
    compute_misfit(model0,Rsurflag,Lsurflag,inp); //misfit for both disp and rf
    printf("test-- do inv\n");
    if((do_inv(1,-2,paralst,para1,model0,Rvmono,Lvmono,Rvgrad,Lvgrad,PREM,kernel1,k1,k2,start,isoflag,Rsurflag,Lsurflag,Nprem,depcri1,depcri2,qscri,qpcri,Rmonoc,Lmonoc,PosAnic,Vposani,Viso,iitercri1,ijumpcri1,fbinnm1,inp))==0){
	#pragma omp critical (writeShareFileError3)
	{
	fprintf(fshare," %s ERROR, do inversin1 failed\n",nodeid);
	}
	continue;

    }
  //------------the model can be either avg model or best model, usually avg model is stable 
    //para_best(paralst,parabest1);
    idlst.clear();
    if((para_avg(paralst,parabest1,Rparastd,Lparastd,idlst))==0){cout<<"#### in para_avg,incorrect paralst.size()\n";exit(0);}
    para2mod(parabest1,model0,modelbest1);
    updatemodelTibet(modelbest1,depcri1,depcri2,qpcri,qscri);

  //------------COMPUTE KERNEL2 BASED ON THE OUTPUT MODEL FROM INV1, AND DO THE 2ed INVERSION-------------
    compute_kernel(parabest1,modelbest1,kernel2,PREM,Nprem,Rsurflag,Lsurflag,isoflag,depcri1,depcri2,qpcri,qscri,nodeid);
    //----------output the model used to compute kernel2, and also output kernel2
    sprintf(tmpstr,"%s/modani_kernel2_%s_%.1f_%.1f.mod",dirlay,nodeid,lon,lat);
    write_initmodAniso(tmpstr,modelbest1);
    
    if(Rsurflag>0){
	sprintf(tmpstr,"%s/kernelRp2ani_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
        fkernel=fopen(tmpstr,"w");
        sprintf(tmpstr," ");
        for(i=0;i<model0.data.Rdisp.npper;i++){
          for(j=0;j<para1.Rnpara+para1.Lnpara;j++){sprintf(tmpstr,"%s %f",tmpstr,kernel2[0][j][i]);}
          fprintf(fkernel,"%f %s\n",model0.data.Rdisp.pper[i],tmpstr);
          sprintf(tmpstr," ");
          }
        fclose(fkernel);
    }
    if(Lsurflag>0){
	sprintf(tmpstr,"%s/kernelLp2ani_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
	fkernel=fopen(tmpstr,"w");
        sprintf(tmpstr," ");
    	for(i=0;i<model0.data.Ldisp.npper;i++){
          for(j=0;j<para1.Lnpara+para1.Rnpara;j++){sprintf(tmpstr,"%s %f",tmpstr,kernel2[2][j][i]);}
          fprintf(fkernel,"%f %s\n",model0.data.Ldisp.pper[i],tmpstr);
          sprintf(tmpstr," ");
        }
    	fclose(fkernel);
    }

    vector<paradef>().swap(paralst);//paralst.clear();
    if((do_inv(2,-2,paralst,parabest1,modelbest1,Rvmono,Lvmono,Rvgrad,Lvgrad,PREM,kernel2,k1,k2,start,isoflag,Rsurflag,Lsurflag,Nprem,depcri1,depcri2,qscri,qpcri,Rmonoc,Lmonoc,PosAnic,Vposani,Viso,iitercri2,ijumpcri2,fbinnm2,inp))==0){
	sprintf(str,"echo %s %.1f %.1f >> point_do_inv_failed.txt",nodeid,lon,lat);
	#pragma omp critical (writeShareFileError4)
	{
	fprintf(fshare," %s ERROR, do inversin2 failed\n",nodeid);
	}
	continue;
    }
    vector<paradef>(paralst).swap(paralst);//shrink
  //------------------write out model_average--------------------------------------------------

    sprintf(modnm1,"%s/AnimodM_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(modnm2,"%s/AnimodK_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(Rdispnm1,"%s/AniRdispM_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(Rdispnm2,"%s/AniRdispK_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(Ldispnm1,"%s/AniLdispM_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(Ldispnm2,"%s/AniLdispK_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(rfoutnm1,"%s/RFM_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(rfoutnm2,"%s/RFK_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);

    idlst.clear();
    if((para_avg(paralst,paraavg,Rparastd,Lparastd,idlst))==0){cout<<"#### in para_avg,incorrect paralst.size()\n";exit(0);}    

    para2mod(paraavg,modelbest1,modelavg);
    write_initmodAniso(outinitnm,modelavg);

    get_misfitMineos(modelavg,paraavg,1,1,depcri1,depcri2,qpcri,qscri,PREM,Nprem,inp,nodeid);
    write_ASC_rf(modelavg,paraavg,modnm1,Rdispnm1,Ldispnm1,rfoutnm1,1,1);
    get_misfitKernel(modelavg,paraavg,modelbest1,parabest1,kernel2,1,1,depcri1,depcri2,qpcri,qscri,inp);
    write_ASC_rf(modelavg,paraavg,modnm2,Rdispnm2,Ldispnm2,rfoutnm2,1,1);
  //-------------------write out model_best --------------------------------------
/*    sprintf(modnm1,"%s/AnimodMbst_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(modnm2,"%s/AnimodKbst_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(Rdispnm1,"%s/AniRdispMbst_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(Rdispnm2,"%s/AniRdispKbst_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(Ldispnm1,"%s/AniLdispMbst_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);
    sprintf(Ldispnm2,"%s/AniLdispKbst_%s_%.1f_%.1f.txt",dirlay,nodeid,lon,lat);

    para_best(paralst,paraavg);
    para2mod(paraavg,modelbest1,modelavg);
    get_misfitMineos(modelavg,paraavg,Rsurflag,Lsurflag,depcri1,depcri2,qpcri,qscri,PREM,Nprem,nodeid);
    write_ASC(modelavg,paraavg,modnm1,Rdispnm1,Ldispnm1,Rsurflag,Lsurflag);
    get_misfitKernel(modelavg,paraavg,modelbest1,parabest1,kernel2,Rsurflag,Lsurflag,depcri1,depcri2,qpcri,qscri,inp);
    write_ASC(modelavg,paraavg,modnm2,Rdispnm2,Ldispnm2,Rsurflag,Lsurflag);    
*/    
    //sprintf(modnm1,"%s/temp_modavg_Ani_iso.txt",dirlay);   
    //sprintf(modnm2,"%s/temp_modavg_Vsh_iso.txt",dirlay);   
    //model_avg(modnm1,modnm2,paralst,model0,depcri1,depcri2,qpcri,qscri,idlst);
/*
    para_best(paralst,paraavg);
    para2mod(paraavg,modelbest1,modelavg);
    get_misfitMineos(modelavg,paraavg,1,1,depcri1,depcri2,qpcri,qscri,PREM,Nprem,nodeid);
    fprintf(fmisfit,"%s %8.1f %8.1f %8g %8g %8g ",nodeid,lon,lat,modelavg.data.misfit,modelavg.data.Rdisp.pmisfit,modelavg.data.Ldisp.pmisfit);

    get_misfitKernel(modelavg,paraavg,modelbest1,parabest1,kernel2,1,1,depcri1,depcri2,qpcri,qscri,inp);
//    fprintf(fmisfit,"%8g %8g %8g\n",modelavg.data.misfit,modelavg.data.Rdisp.pmisfit,modelavg.data.Ldisp.pmisfit);   
    fprintf(fmisfit,"%s %8.1f %8.1f %8g %8g %8g\n",nodeid,lon,lat,modelavg.data.misfit,modelavg.data.Rdisp.pmisfit,modelavg.data.Ldisp.pmisfit);   
*/
    vector<vector<vector<double> > >().swap(kernel1);//free
    vector<vector<vector<double> > >().swap(kernel2);//free
    vector<paradef>().swap(paralst);//free
    vector<double>().swap(Rparastd);//free
    vector<double>().swap(Lparastd);//free
  }//for ipoint
  vector<vector<double> >().swap(PREM);//free
  //fclose(fmisfit); 
  fclose(fshare);
  printf("total CPU time used = %f (sec); wall time = %f\n",float(clock()-dtall)/CLOCKS_PER_SEC,float(time(0)-dtall2));
  return 1;
}//main
